---
theme: black
defaultTemplate: "[[tpl-base-no-title]]"
transition: fade
slideNumber: c/t
---

<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap');
.code-block-fixed {  
	display: block;  padding: 5px;  overflow: auto; min-height:100px;  max-height: 800px;  word-wrap: normal;
}
.reveal .code-wrapper {
	font-size: 0.7em;
}
.reveal, .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
  font-family: 'Noto Sans KR', sans-serif;
  text-transform: none;
   margin-bottom: 1px;
}
.reveal p {
   margin: 10px;
}
li:last-of-type {
  margin-bottom: 10px;
}
</style>

<!-- slide template="[[tpl-title]]" -->
::: title
V2X.Service팀 대상 Java 기초 세미나<!-- element style="color: black" -->
:::

::: author
V2X연구소
:::

::: date
📆 2023-07-07
:::

---

<!-- slide bg="https://media1.giphy.com/media/qgQUggAC3Pfv687qPC/giphy.gif?cid=ecf05e47yk0tfe926f0b2e9d97ce8fxo8imtxi4zdbpmprx3&ep=v1_gifs_search&rid=giphy.gif&ct=g" data-background-opacity="0.5"-->

## 들어가기 전에

본 기초 세미나는 **가장 빨리 만나는 코어 자바 9** 를 기본 자료로 하여, C++개발자에게 기초 Java를 교육하기 위해 작성되었다.

- 특징:
	- Java SE 9 기준으로 설명
	- C++과 동일/유사한 문법은 소략함
	- C++과 Java의 차이를 강조함

---

<!-- .slide: bg="white" data-background-opacity="0.5"-->

## 기초 프로그래밍 구조

- 핵심 내용:
	- 자바는 모든 메서드를 클래스 안에 선언한다. 비정적 메서드는 메서드가 속한 클래스의 객체로 호출한다
	- 정적 메서드는 객체로 호출하지 않는다. 프로그램 실행은 정적 메서드인 main에서 시작한다
	- 자바의 기본 타입은 총 여덟 가지(정수 타입 네 가지, 부동소수점 타입 두 가지, char, boolean)다
	- 자바의 연산자와 제어 구조는 C나 C++과 아주 비슷하다
	- Math 클래스는 일반적인 수학 함수를 제공한다
	- String 객체는 문자(엄밀히 말하면 UTF-16 인코딩된 문자)의 연속이다
	- System.out 객체로 터미널에 결과를 표시할 수 있다. System.in에 Scanner를 연결하면 터미널에 입력한 것을 읽을 수 있다
	- 배열과 컬렉션은 타입이 같은 요소를 모으는 데 사용한다

---
## 첫 번째 프로그램

### 코드
```java
package ch01.sec01;

public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("Hello, World!");
	}
}
```

### 컴파일 및 실행
```bash
javac ch01/sec01/HelloWorld.java
javac ch01.sec01.HelloWorld
```

### REPL[^1]
```jshell
jshell> "Hello, World!".length()
$1 ==> 13
```

::: footnote
1: Read-Evaluate-Print Loop
:::

---
## 기본 타입

자바는 객체 지향 언어이지만 모든 값이 객체인 것은 아니다. 몇 가지 값은 기본 타입(primitive type)에 속한다:
- 기본 타입 중 네 가지(byte, short, int, long)는 부호 있는 정수 타입이고
- 두 가지(float, double)은 부동소수점 타입이며,
- 하나는 문자열 인코딩에 사용하는 문자 타입인 char,
- 나머지 하나는 진릿값을 나타내는 boolean 타입이다

---
## 변수

```java
int total = 0;
int total = 0; count;
Random generator = new Random();
```

- 객체를 생성할 때는 *new* 를 사용한다
- 메서드 안에 변수를 선언했다면 해당 변수를 반드시 초기화한 후 사용해야 한다:
```java
int count;
count++; // 오류! 초기화되지 않음
```

### 상수
final 키워드는 한번 할당하면 변경할 수 없는 값에 사용한다:

```java
final int DAYS_PER_WEEK = 7;
```

초기화는 미룰 수도 있다:
```java
final int DAYS_IN_FEBRURARY;
if (leapYear) { DAYS_IN_FEBRURARY = 29; }
```

---
## 산술 연산, 기본 계산
C++과 거의 유사하다.

---
## 문자열
문자열은 문자의 시퀀스다. 자바에서는 유니코드 문자라면 무엇이든 문자열에 쓸 수 있다.

```java
String location = "Java";
String greeting = "Hello " + location;
```

```java
String greeting = "Hello, World!";
String location = greeting.substring(7, 12);
```

### 문자열 비교
두 문자열이 같은지 검사하려면 equals 메서드를 사용해야 한다. $==$ 가 아니다.
- $==$ 사용시 객체의 동일성을 비교한다

---
## 입력과 출력

### 표준 출력
```java
System.out.println
```

### 표준 입력
```java
Scanner in = new Scanner(System.in);
System.out.println("What is your name?");
String name = in.nextLine();
```

---
## 제어 흐름
C++과 거의 유사하다.

### 레이블 브레이크 
```java
outer:
while (...) {
	while (...) {
		...
		if (...) break outer;
		...
	}
	...
}
// break시 이 위치로 건너뜀
```

---
## 배열과 배열 리스트
배열 생성:
```java
String[] names;
names = new String[100];

// 혹은 다음과 같이 결합하여 사용
String[] names = new String[100];
```

```java
// new variable
int[] primes = { 2, 3, 5 };

// update variable
primes = new int[] { 3, 5, 6 };
```

C++ 배열과 마찬가지로, 한번 생성하면 절대로 길이를 변경할 수 없다.

배열 리스트:
```java
ArrayList<String> friends = new ArrayList<>(List.of("Peter", "Paul"));
String first = friends.get(0);
friends.set(1, "Mary");
```

---
## 기본 타입의 레퍼 클래스
자바 제네릭 클래스는 기본 타입을 타입 매개변수로 사용할 수 없다. 모체 클래스(ArrayList 등)가 처음에 Object만을 가정하고 작성되었기 때문이다.

Object와 호환되는 클래스를 인자로 넣으면 컴파일 시점에 클래스가 Object로 형변환되어 사용된다

```java
// Entry<K, V> 클래스는 다음과 같이 변환됨
public class Entry {
	private Object key;  // K
	private Object value;  // V

	public Entry(Object key, Object value) {
		this.key = key;
		this.value = value;
	}

	public Object getKey() { return key; }
	public Object getValue() { return value; }
}
```

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 객체 지향 프로그래밍

- 핵심 내용:
	- 변경자 메서드는 객체 상태를 변경하지만, 접근자 메서드는 객체 상태를 변경하지 않는다
	- 자바에서 변수는 객체가 아니라 객체 참조를 저장한다
	- 클래스 선언 안에 인스턴스 변수와 메서드 구현을 선언한다
	- 인스턴스 메서드는 객체로 호출하며, 호출된 메서드에서는 이 객체를 this 참조로 접근할 수 있다
	- 생성자는 클래스와 이름이 같다. 클래스 안에 오버로드된 생성자를 여러 개 포함할 수 있다
	- 정적 변수는 어떤 객체에도 속하지 않는다. 정적 메서드는 객체로 호출하지 않는다
	- 클래스는 패키지로 조직화된다. 임포트 선언을 하면 프로그램 안에서 패키지 이름을 쓰지 않아도 된다
	- 클래스 안에 다른 클래스를 선언할 수 있다
	- 내부 클래스는 비정적 중첩 클래스다. 내부 클래스의 인스턴스는 자신을 생성한 바깥쪽 클래스의 객체를 참조한다
	- javadoc 유틸리티는 소스 파일을 처리해 선언된 내용과 프로그래머가 작성한 주석으로 HTML 파일을 만든다

---
## 객체 참조
C++에서는 변수에 실제 객체(즉, 객체의 상태를 구성하는 비트들)을 담을 수 있다. 하지만 자바에서는 그렇지 않다.

변수에는 오직 객체 참조(reference)만 담을 수 있다.
- 실제 객체는 다른 곳에 있고, 참조는 실제 객체를 찾아내는 방법이다

---
## this 참조
객체의 메서드를 호출할 때 해당 객체가 this로 설정된다. 원한다면 메서드를 구현할 때 this 참조를 사용해도 된다.

```java
public void raiseSalary(double byPercent) {
	double raise = this.salary * byPercent / 100;
	this.salary += raise;
}
```

---
## 값을 사용한 호출(Call by value)
자바는 값을 사용한 호출을 수행한다. 다음과 같은 클래스 메서드를 보자:

```java
public class EvilManager {
	private Random generator;
	...
	public void giveRandomRaise(Employee e) {
		double percentage = 10 * generator.nextGaussian();
		e.raiseSalary(percentage);
	}
}
```

다음과 같이 호출한다고 하자:

`boss.giveRandomRaise(fred)`

그러면 fred를 e 매개변수로 복사한다. `giveRandomRaise` 메서드는 두 참조가 공유하는 객체를 변경한다.

---
따라서, 자바에서는 기본 타입 매개변수를 업데이트하는 메서드는 작성할 수 없다. 예를 들어 다음과 같이 double 값을 증가시키는 메서드는 의도한 대로 작동하지 않는다.

```java
public void increaseRandomly(double x) {
	double amount = x * generator.nextDouble();
	x += amount;
}
```

다음과 같이 호출한다고 하자: `boss.increaseRandomly(sales)`

그러면 sales가 x로 복사될 뿐이다. 변경된 x는 유효 범위(스코프)를 빠져나갈 때 소멸한다.

같은 이유로 객체 참조를 다른 참조로 바꾸는 메서드도 작성할 수 없다:
```java
public class EvilManager {
	...
	public void replaceWithZombie(Employee e) {
		e = new Employee("", 0);
	}
}
```


---
## 생성자

기본:
```java
public Employee(String name, double salary) {
	this.name = name;
	this.salary = salary;
}
```

오버로딩:
- 생성자는 두 가지 이상의 버전으로 제공할 수 있다.

다른 생성자에서 특정 생성자 호출:
```java
public Employee(double salary) {
	this("", salary); // Employee(String, double)을 호출한다
	// 이후에 다른 문장이 올 수 있다
}
```

기본 초기화:
- 생성자 안에서 인스턴스 변수를 명시적으로 설정하지 않으면 변수는 기본값으로 설정된다

---
## 정적 변수와 정적 메서드
### 정적 변수
클래스 안에 변수를 static으로 선언하면 해당 변수는 클래스 당 하나만 존재한다. 정적 변수는 변경 가능하다.

### 정적 상수
변경 가능한 정적 변수는 드물게 사용되지만, 정적 상수(static final 변수)는 매우 일반적으로 사용된다.

### 정적 초기화 블록
초기화 작업이 추가로 필요한 경우 정적 초기화 블록을 사용할 수 있다.
```java
public class CreditCardForm {
	private static final ArrayList<Integer> expirationYear = new ArrayList<>();
	static {
		// 다음 20개 연도를 배열 리스트에 추가한다
		int year = LocalDate.now().getYear();
		for (int i = year; i <= year + 20; i++) {
			expirationYear.add(i);
		}
	}
}
```
<!-- element style="font-size: 0.6em" -->

---
### 정적 메서드
정적 메서드는 객체에 작동하지 않는 메서드다. 예를 들어 Math클래스의 pow 클래스는 정적 메서드다.

### 정적 메서드의 흔한 사용처
팩토리 메서드를 만드는 데 사용한다. 팩토리 메서드는 클래스의 새 인스턴스를 반환하는 정적 메서드를 의미한다. 예를 들어 NumberFormat 클래스에는 다양한 스타일에 대응해서 포매터 객체를 돌려주는 팩토리 메서드가 있다:

```java
NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
NumberFormat percentFormatter = NumberFormat.getPercentInstance();
```

왜 생성자 대신 팩토리 메서드를 사용할까?
- 생성자를 구별하는 유일한 방법은 매개변수 타입이다. 따라서 매개변수가 같은 생성자를 두 개 둘 수 없다

---
## 패키지, 중첩 클래스
- 클래스는 패키지로 구조화할 수 있다
- 또한, 클래스 내에 클래스를 둘 수도 있다:
	- 이러한 클래스를 중첩 클래스라고 한다
	- 중첩 클래스는 가시성을 제한하기 위해 사용된다
	- 또한 Element, Node, Item처럼 일반적인 이름을 사용하면서도 정돈하고 싶을 때 유용하다

---
## 문서화 주석
JDK에 포함된 javadoc은 사실상의 자바 문서화 표준 도구이다.

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 인터페이스와 람다 표현식

- 핵심 내용:
	- 인터페이스는 구현 클래스에서 반드시 구현해야 하는 메서드를 명시한다
	- 인터페이스는 해당 인터페이스를 구현하는 모든 클래스의 슈퍼타입이다. 따라서 구현 클래스의 인스턴스를 인터페이스 타입 변수에 할당할 수 있다
	- 인터페이스는 정적 메서드를 포함할 수 있다. 인터페이스의 모든 변수는 자동으로 public static final이다
	- 인터페이스는 구현 클래스에서 상속하거나 오버라이드 할 수 있는 기본 메서드를 포함할 수 있다
	- 인터페이스는 구현 클래스에서 호출하거나 오버라이드 할 수 없는 비공개 메서드를 포함할 수 있다
	- Comparable과 Comparator 인터페이스는 객체를 비교할 때 사용한다
	- 함수형 인터페이스는 단일 추상 메서드를 가진 인터페이스다
	- 람다 표현식은 나중에 실행할 수 있는 코드 블록이다
	- 람다 표현식은 함수형 인터페이스로 변환된다
	- 메서드 참조와 생성자 참조는 메서드와 생성자를 호출하지 않고 참조한다
	- 람다 표현식과 지역 클래스는 자신을 감싸는 유효 범위에 있는 사실상 최종 변수에 접근할 수 있다

---
## 인터페이스의 예
```java
public interface IntSequence {
	boolean hasNext();
	int next();
}

public class SquareSequence implements IntSequence {
	private int i;
	public boolean hasNext() { return true; }
	public int next() { i++; return i*i; }
}
```

```java
class HelloTask implements Runnable {
	public void run() {
		for (int i = 0; i < 1000; i++) {
			System.out.println("Hello, World!");
		}
	}
}
Runnable task = new HelloTask();
Thread thread = new Thread(task);
thread.start();
```

T 타입의 모든 값을 변환 없이 S타입의 변수에 할당할 수 있다면 S타입은 T타입의 슈퍼타입이다. T타입은 S타입의 서브타입이다.

---
## 람다 표현식

람다 표현식은 나중에 한 번 이상 실행할 수 있게 전달하는 코드 블록이다. 자바에서 람다를 활용하는 예로는 다음과 같은 경우가 있다:
- Arrays.sort에 비교 메서드 전달
- 별도의 스레드에서 태스크 실행
- 버튼을 클릭했을 때 일어날 액션 지정

```java
Runnable task = () -> { for (int i = 0; i < 1000; i++) doWork(); }
```

자바에는 함수 타입이 없다. 람다는 함수형 인터페이스를 통해 구현된다.
- 함수형 인터페이스: 단일 추상 메서드를 가진 인터페이스

따라서 람다는 Object 타입 변수와 호환되지 않는다. 함수형 인터페이스의 구현체여야 하기 때문이다

---
## 기본 함수형 인터페이스

기본 함수형 인터페이스 세트가 언어적으로 제공되나, 없는 경우 직접 만들어야 한다:

```java
@FunctionalInterface
public interface PixelFunction {
	Color apply(int x, int y);
}
```

---
## 메서드 참조와 생성자 참조
자바는 제네릭 타입으로 구성된 배열을 반환할 수 없다. 배열은 기본적으로 Object로 반환된다:
```java
Object[] employees = stream.toArray();
```

toArray는 생성자 참조를 통해 이 문제를 해결한다
```java
Employee[] buttons = stream.toArray(Employee[]::new);
```

---
## 지역 클래스와 익명 클래스
### 지역 클래스
호출하는 쪽이 구현 클래스에 관심이 없는 경우 구현 클래스를 메서드 안에 선언하여 대응할 수 있다:
```java
private static Random generator = new Random();

public static IntSequence randomInts(int low, int high) {
	class RandomSequence implements IntSequence {
		public int next() { return low + generator.nextInt(high - low + 1 ); }
		public boolean hasNext() { return true; }
	}
	return new RandomSequence();
}
```

---
### 익명 클래스
다음 표현식은 명기된 인터페이스를 상속하는 클래스의 하나뿐인 객체를 생성한다:
```java
new interface() { 메서드 구현 }
```

자바에 람다 표현식이 생기기 전에는 익명 클래스가 Runnable, Comparator, Functional Object를 만드는 가장 간결한 문법이다. 레거시 코드에서 종종 익명 클래스를 보게 될 것이다.

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 상속과 리플렉션

- 핵심 내용:
	- 서브클래스는 슈퍼클래스에서 private이 아닌 메서드를 상속하거나 오버라이드 할 수 있다
	- super 키워드로 슈퍼클래스의 메서드나 생성자를 호출할 수 있다
	- final 메서드는 오버라이드 할 수 없고, final 클래스는 확장할 수 없다
	- abstract 메서드는 구현이 없고, abstract 클래스의 인스턴스는 생성할 수 없다
	- 슈퍼클래스의 protected 멤버는 서브클래스 메서드에서 접근할 수 있다. 하지만 같은 서버클래스의 객체에 적용할 때만 가능하다. protected 멤버는 패키지 내부에서도 접근할 수 있다
	- 클래스는 모드 Object의 서브클래스다. Object 클래스에는 toString, equals, hashCode, clone 메서드가 있다
	- 열거 타입은 Enum의 서브클래스다. Enum 클래스에는 인스턴스 메서드 toString, compareTo 등과 정적 메서드 valueOf가 있다
	- Class 클래스는 자바 타입과 관련된 정보를 제공한다. 정보를 제공할 수 있는 자바 타입은 클래스, 배열, 인터페이스, 기본 타입, void다

---
## 클래스 확장
C++과 유사하다.

---
## Object: 보편적 슈퍼클래스
Object 클래스는 모든 자바 객체에 적용할 수 있는 메서드를 정의하고 있다:
| 메서드                       | 설명                                     |
| ---------------------------- | ---------------------------------------- |
| String toString()            | 객체의 문자열 표현                       |
| boolean equals(Object other) | 객체 비교용                              |
| int hashCode()               | 객체의 해시코드                          |
| Class\<?\> getClass()        | 리플렉션                                 |
| protected Object clone()     | 객체를 복제(기본: 얕은 복사)             |
| protected void finalize()    | 객체 회수시 작동(오버라이드 하지 마시오) |
| wait, notify, notifyAll      | 병행 프로그래밍 전용                     |

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 예외, 단정, 로깅
- 핵심 내용
	- 프로그램에서 예외를 던지면 해당 예외와 가장 가까운 예외 핸들러로 제어가 전달된다
	- 자바에서는 컴파일러가 검사 예외를 추적한다
	- 예외를 처리하려면 try-catch 구조를 사용해야 한다
	- try-with-resources 문은 정상적으로 실행을 마치거나 예외가 일어나면 자동으로 리소스를 닫는다
	- 실행이 정상적으로 진행되든 그렇지 않든 반드시 해야 할 일이 있을 때는 try-finally 구조를 사용한다
	- 예외를 잡아서 다시 던지거나 다른 예외와 연쇄할 수 있다
	- 스택 추적은 실행의 특정 지점에서 대기 중인 모든 메서드 호출을 보여준다
	- 클래스에 단정 검사를 활성화하면, 단정은 조건을 검사해 해당 조건을 만족하지 못하면 오류를 일으킨다

---
<!-- slide template="[[tpl-2col-1_1]]" -->

::: title
#### 예외 처리
:::

::: left
![[core java 9 - throw classes.png|400]]

:::

::: right
### 에러
- Error는 프로그램이 처리할 수 없는 상황에 발생시켜야 한다
	- 예: 메모리 고갈

### 예외의 종류
- 비검사 예외(unchecked)는 실행시간 예외이며, 잡아내지 않아야 하는(예외처리가 의미가 없는)경우에 해당한다
	- 예: out of bound
- 검사 예외는 **실패가 발생할 수 있으며** 예외처리가 의미있는 경우에서 사용한다
	- 예: 입출력에 대한 방어적 프로그래밍
:::

---
### try-with-resources 문
AutoCloseable 인터페이스 구현체에 한해 특별한 형태의 try문을 사용할 수 있다:
```java
try (PrintWriter out = new PrintWriter("output.txt")) {
	for (String line : lines) {
		out.println(line.toLowerCase());
	}
}
// out.close()가 호출됨
```
여러 리소스를 세미콜론으로 구분해 try안에 선언할 수 있으며, 이 경우 초기화 순서의 역순으로 닫힌다.

---
## 단정
단정은 일반적으로 사용하는 방어적 프로그래밍 방법이다.

```java
assert condition;  // 조건이 거짓이면 AssertionError를 던짐

// expression부분이 오류 객체의 메시지가 되는 문자열로 변환됨
assert condition : expression;
```

단정은 기본적으로 비활성화되어 있다. 활성화하려면 -enableassertions나 -ea 옵션 적용이 필요하다.

단, 단정을 활성화하거나 비활성화 하는 일은 클래스 로더가 처리하므로 프로그램을 다시 컴파일할 필요는 없다.

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 제네릭 프로그래밍

- 자바의 제네릭 프로그래밍은 왜 복잡한가?
	- 자바가 생긴 지 꽤 지난 시점에 제네릭이 추가됨
	- 하위 호환성이 유지되도록 설계됨

- 핵심 내용
	- 제네릭 클래스는 타입 매개변수를 한 개 이상 받는 클래스다
	- 제네릭 메서드는 타입 매개변수를 받는 메서드다
	- 타입 매개변수가 타입 한 개 이상의 서브타입이 되도록 요구할 수 있다
	- 제네릭 타입은 불변 타입이다. 즉, S가 T의 서브타입일 때 `G<S>`와 `G<T>` 사이에는 아무런 관계가 없다
	- 제네릭 클래스와 제네릭 메서드를 컴파일할 때 타입 매개변수가 소거된다
	- 타입 소거로 제네릭 타입에 많은 제약이 생긴다. 특히 제네릭 클래스나 배열의 인스턴스 생성, 제네릭 타입으로 캐스트, 제네릭 타입 객체를 예외로 던지는 일을 할 수 없다

---
## 제네릭 클래스

### 예시 클래스
```java
public class Entry<K, V> {
	private K key;
	private V value;

	public Entry(K key, V value) {
		this.key = key;
		this.value = value;
	}

	public K getKey() { return key; }
	public V getValue() { return value; }
}
```

---
### 변환체

```java
// Entry<K, V> 클래스는 다음과 같이 변환됨
public class Entry {
	private Object key;  // K
	private Object value;  // V

	public Entry(Object key, Object value) {
		this.key = key;
		this.value = value;
	}

	public Object getKey() { return key; }
	public Object getValue() { return value; }
}
```

---
## 제네릭 메서드
제네릭 클래스가 타입 매개변수를 받는 클래스인 것처럼 제네릭 메서드는 타입 매개변수를 받는 메서드다. 제네릭 메서드는 일반 클래스나 제네릭 클래스에 속할 수 있다.

```java
Arrays.<String>swap(friends, 0, 1);
```

타입을 명시적으로 지정할 때는 함수 앞에 적어야 한다.

---
## 타입 경계
제네릭 클래스/메서드가 받는 타입 매개변수에 제한을 걸 수 있다. 타입이 특정 클래스를 확장하거나 인터페이스를 구현해야 하도록 할 수 있다.
```java
public static <T extends AutoCloseable> void closeAll(ArrayList<T> elems)
		throws Exception {
	for (T elem : elems) elem.close();
}
```

---
## 타입 가변성과 와일드카드
배열은 공변성을 가지고 있으나 ArrayList는 제네릭이므로 가변성을 가지고 있지 않다. 제네릭은 와일드카드를 통해 이 문제를 해결한다.

### 서브타입 와일드카드
```java
public static void printNames(ArrayList<? extends Employee> staff) {
	for (int i = 0; i < staff.size(); i++) {
		Employee e = staff.get(i);
		System.out.println(e.getName());
	}
}
```

### 슈퍼타입 와일드카드
```java
<? super Employee>
```

---
## 자바 가상 머신에서 보는 제네릭
자바 설계자들이 자바에 제네릭 타입과 메서드를 추가하던 당시로 거슬러 올라가 보자:
- 설계자들은 클래스의 제네릭 형태가 기존 버전 클래스와 호환되게 하려고 했다
- 제네릭이 없던 시절의 ArrayList 클래스는 Object 타입 요소를 모았다
	- 여기에 `ArrayList<String>` 과 같은 문법을 추가하고 싶었다
- 그래서 설계자들은 타입을 지우는 방식을 사용하였다

---
## 제네릭의 제약
- 기본 타입 인수를 사용할 수 없다
	- `ArrayList<Integer>` 를 만들고 오토박싱하면 된다
- 실행 시간에는 모든 타입이 RAW 형태이다
- 타입 변수를 인스턴스화 할 수 없다
	- `T(...)` 혹은 new `T[...]` 불가능
	- `String[] greetings = Arrays.repeat(10, "Hi", String[]::new);` 와 같은 코드를 사용해야 한다
- 매개변수화된 타입의 배열을 생성할 수 없다
	- `Entry<String, Integer>[] entries` 불가
	- `ArrayList<Entry<String, Integer>> entries` 로 대체 가능
- 정적 컨텍스트에서 클래스 타입 변수가 유효하지 않다
- 제네릭 클래스의 객체는 예외로 던지거나 잡을 수 없다
	- Throwable의 제네릭 서브클래스는 불가능
		- `public class Problem<T> extends Exception`

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 컬렉션

- 핵심 내용:
	- Collection 인터페이스는 Map 인터페이스로 나타내는 맵을 제외하고 모든 컬렉션에 공통 메서드를 제공한다
	- 리스트는 각 요소에 정수 인덱스가 붙은 순차 컬렉션이다
	- 집합은 효율적인 포함 여부 검사에 최적화되어 있다. 자바에는 HashSet과 TreeSet 구현이 있다
	- 맵은 HashMap과 TreeMap 구현 중에서 선택할 수 있다. LinkedHashMap은 삽입 순서를 유지한다
	- Collection 인터페이스와 Collections 클래스에는 집합 연산, 검색, 정렬, 뒤섞기(셔플링)처럼 다양하고 유용한 알고리즘이 있다
	- 뷰는 표준 컬렉션 인터페이스를 이용해 어딘가 저장된 데이터에 접근할 수 있게 한다

---
## 컬렉션 프레임워크 개요

![[core java 9 - collections.png|800]]

---
## 반복자

각 컬렉션은 특정 순서로 요소를 순회하는 메서드를 제공한다:
```java
Iterator<T> iterator()
```

```java
Collection<String> coll = ...;
Iterator<String> iter = coll.iterator();
while (iter.hasNext()) {
	String element = iter.next();
	// element를 처리한다
}
```

간단하게 향상된 for 루프를 사용해도 된다:
```java
for (String element : coll) {
	// element를 처리한다
}
```

---
## 집합
C++의 set과 유사하다.

---
## 맵
키를 정렬 순서로 방문해야 하는 경우라면 TreeMap을, 그렇지 않다면 HashMap을 사용한다.

get 메서드는 키가 없으면 null을 반환하며, null이 반환되면 값이 언박싱될 때 NullPointerException이 일어난다. 이를 방지하기 위한 코드는 다음과 같다:

```java
int count = counts.getOrDefault("Alice", 0);
```

특정 메서드는 맵 데이터의 사본이 아닌, 해당 맵에 연결된 뷰를 제공한다:

```java
Set<K> keySet()
Set<Map.Entry<K, V>> entrySet()
Collection<V> values()
```

뷰에서 키나 엔트리를 제거하면 원본 맵의 데이터도 제거된다.

다음과 같은 순회가 가능하다:

```java
counts.forEach((k, v) -> { ... });
```

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 스트림
- 핵심 내용:
	- 반복자는 특정 순회 전략을 내포하므로 효율적인 동시 실행을 방해한다
	- 컬렉션, 배열, 발생기, 반복자에서 스트림을 생성할 수 있다
	- filter로 요소를 선택하고, map으로 요소를 변환한다
	- 스트림의 결과 추출 메서드로는 count, max, min, findFirst, findAny 등이 있다. 이 중 일부는 Optional 값을 반환하다
	- Optional 타입의 목적인 null값을 안전하게 다루는 것이다. null을 안전하게 사용하려면 ifPresent와 orElse 메서드를 사용하면 된다
	- 스트림 결과는 컬렉션, 배열, 문자열, 맵으로 모을 수 있다
	- 병렬 스트림은 스트림 연산을 자동으로 병렬화한다

---
## 반복을 스트림으로 변환하기
컬렉션에 대한 다음 반복 코드를 보자:
```java
int count = 0;
for (String w : words) {
	if (w.length() > 12) count++;
}
```

스트림을 이용하면 다음과 같이 연산을 수행할 수 있다:
```java
long count = words.stream()
	.filter(w -> w.length() > 12)
	.count();
```

병렬 연산으로 바꾸기 위해서는 다음과 같이 변경한다:
```java
long count = words.parallelStream()
	.filter(w -> w.length() > 12)
	.count();
```

Collection 인터페이스의 stream 메서드를 사용하면 어떤 컬렉션이든 스트림으로 변활할 수 있다.

---
## 스트림 생성 
배열인 경우 정적 메서드 Stream.of를 사용해야 한다.

```java
Stream<String> words = Stream.of(content.spit("\\PL+"));
// split는 String[] 배열을 반환한다.
```

of 메서드는 가변 인수 매개변수를 받으므로 인수가 몇 개든 스트림을 생성할 수 있다:

```java
Stream<String> song = Stream.of("gently", "down", "the", "stream");
```

---
## filter, map 메서드
스트림 변환은 또 다른 스트림에 들어 있는 요소에서 파생한 요소의 스트림을 만들어 낸다. filter 변환은 특정 조건과 일치하는 요소로 구성된 새 스트림을 돌려준다:

```java
// 문자열 스트림 중 긴 단어만 추출하여 또 다른 스트림으로 변환
List<String> words = ...;
Stream<String> longWords = words.stream().filter(w -> w.length() > 12);
```

특정 방식으로 스트림 내의 값을 변환하고 싶을 때가 있다:
```java
// 모든 단어를 소문자로 변환
Stream<String> lowercaseWords = words.stream().map(String::toLowerCase);
```

---
## 옵션 타입
`Optional<T>`는 T타입 객체 또는 객체가 없음을 나타내는 래퍼이다:
```java
// 옵션 값으로 래핑된 문자열. 문자열이 없는 경우 ""
String result = optionalString.orElse("");
```

다음과 같이 기본 값을 계산하는 코드도 호출할 수 있다:
```java
// 필요할 때만 함수가 호출된다
String result = optionalString.orElseGet(() -> System.getProperty("myapp.default"));
```

값이 없을 때는 다음과 같이 예외를 던져도 된다:
```java
// 예외 객체를 돌려주는 메서드를 전달한다
String result = optionalString.orElseThrow(IllegalStateException::new);
```

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 병렬 프로그래밍

- 핵심 내용:
	- Runnable은 비동기로 실행될 수 있지만 결과를 반환하지 않는 태스크를 나타낸다
	- ExecutorService는 태스크 인스턴스의 실행을 스케쥴링한다
	- Callable은 비동기로 실행할 수 있고 결과를 내는 태스크를 나타낸다
	- 잠금보다는 병렬 알고리즘과 스레드 안전 자료 구조를 선호하라
	- 스레드 안전 해시맵으로는 ConcurrentHashMap이 있다
	- 잠금은 한 시점에 한 스레드만 임계 영역을 실행함을 보장한다

---
## 병행 태스크
자바에서 태스크와 스레드를 일대일 관례로 만드는 것은 바람직하지 않다. 실행자 서비스(executor service)는 태스크를 스케줄링하고 해당 태스크를 수행할 스레드를 선택해 실행한다.

```java
Runnable task = () -> { ... };
ExecutorService executor = ...;
executor.execute(task);
```

## 퓨처
Runnable은 태스크를 수행하지만 값을 내지 않는다. 결과를 계산하는 태스크가 있다면 `Callable<V>` 인터페이스를 사용해야 한다.
`Callable<V>`의 call 메서드는 Runnable의 run 메서드와 달리 V타입 값을 반환한다.

```java
ExecutorService executor = Executors.newFixedThreadPool();
Callable<V> task = ...;
Future<V> result = executor.submit(task);
```

태스크를 제출하면 퓨처를 반환받는다.

---
## 안전한 병행성을 실현하는 전략
- 가두기: 각 태스크에서 결과를 계산한 다음 최종적으로 결합할 것
- 불변성: 불변 객체를 공유하는 일은 안전함
- 잠금 설정: 한번에 한 태스크에만 자료 구조에 접근할 수 있는 권한을 줌

---
## 병렬 알고리즘
### 병렬 스트림

```java
long result = coll.parallelStream().filter(s -> s.startsWith("A")).count();
```

### 잠금
```java
Lock countLock = new ReentrantLock();  // 여러 스레드가 공유
int count;  // 여러 스레드가 공유

...

countLock.lock();
try {
	count++;  // 임계 영역
} finally {
	countLock.unlock();  // 잠금을 확실히 해제
}
```

---
자바에서 잠금의 깔끔한 해제는 쉽지 않음
- C++의 RAII형태의 사용이 불가능하며, lock 호출시 unlock을 수동으로 호출해야만 함
- 대안으로 synchronized 키워드가 존재함

따라서 애플래케이션 프로그래머는 잠금을 최후의 방법으로만 이용함:
- 불변 데이터를 이용하거나 가변 데이터를 태스크에서 태스크로 전달하는 방식을 이용
- 공유가 필요한 경우 ConcurrentHashMap과 같은 이미 존재하는 스레드 안전 구조 이용

---
## synchronized 키워드

자바의 모든 객체에는 고유 잠금(intrinsic lock)이 있어 명시적인 잠금을 사용할 필요가 없음.

```java
synchronized (obj) {
	// critical section
}
```

위 형태는 다음 코드와 본질적으로 동일함:
```java
obj.intrinsicLock.lock();
try {
	// critical section
} finally {
	obj.intrinsicLock.unlock();
}
```

---
메서드를 synchronized로 선언할 수도 있음: 
- `public synchronized void method() {}` :

```java
public void method() {
	this.intrinsicLock.lock();
	try {
		// body
	} finally {
			this.intrinsicLock.unlock();
	}
}
```
동기화 카운터 예:
```java
public class Counter {
	private int value;
	public synchronized int increment() {
		value++;
		return value;
	}
}
```

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 애너테이션

- 핵심 내용:
	- 애너테이션은 선언에 public이나 static같은 제어자를 사용하는 것처럼 붙일 수 있다
	- 애너테이션은 @기호로 시작하며, 요소라고 하는 키/값 쌍을 포함할 수 있다
	- 애너테이션 값은 반드시 컴파일 시간 상수여야 한다
	- 애너테이션을 정의하려면 애너테이션 요소에 대응하는 메서드가 있는 애너테이션 인터페이스를 명시해야 한다

---
## 애너테이션 사용

JUnit 4 테스팅 도구는 클래스를 테스트할 때 @Test가 붙은 모든 메서드를 호출한다:

```java
public class CacheTest {
	...
	@Test public void checkRandomInsertions()
}
```

## 애너테이션 요소
애너테이션은 요소(element)라고 하는 키/값 쌍을 포함할 수 있다: `@Test(timeout=10000)`

애너테이션 요소는 다음 중 하나임:
- 기본 타입 값, String
- Class 객체, enum 인스턴스
- 애너테이션
- 위 5개 항목의 배열(배열의 배열은 안 됨)
	- `@Target({ElementType.TYPE, ElementType.METHOD})`

---
## 애너테이션 정의

애너테이션은 반드시 @interface 문법을 사용해 애너테이션 인터페이스로 선언해야 한다:

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {
	long timeout();
	...
}
```

---
## 표준 애너테이션
자바 API는 java.lang, java.lang.annotation, javax.annotation 패키지에 애너테이션을 정의해 놓았다:

- Override
- Deprecated
- SuppressWarnings
- SafeVarargs
- FunctionalInterface
- PostConstruct
- PreDestroy
- Resource
- Resources
- Generated
- Target
- Retention
- Documented
- Inherited
- Repeatable

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 날짜와 시간 API

시간을 다루기는 왜 어려울까? 문제는 사람이다. Time64만으로 소통할 수 있다면, 1371409200에 만나자, 늦지 마! 같이 말할 수 있을 것이다.

사람은 Time64를 읽을 수 없다. 타임존, 써머타임, 윤초 등이 시간을 다루기 어렵게 만든다.

자바 1.0에는 고지식한 Date 클래스가 있었지만, 결국 자바 1.1에 Calendar를 도입하였고, Date는 비권장 조치되었다. 그러나 Calendar API또한 윤초 등에 대한 고려가 없었다. 자바 8에서는 java.time이 권장 클래스로 추가되었다.

java.util.Date(deprecated) ▶ java.util.GregorianCalendar(not good) ▶ java.time

---

<!-- slide bg="white" data-background-opacity="0.5"-->

## 자바 플랫폼 모듈 시스템

자바9에서 자바 플랫폼 모듈 시스템(JPMS)가 도입되었다:

- 두 가지 이점:
	- 강력한 캡슐화: 어느 패키지를 접근할 수 있게 할지 제어 가능
	- 신뢰할 수 있는 구성: 클래스 중복이나 누락 같은 흔한 클래스 패스 문제 해결 가능

- 핵심 내용:
	- JPMS는 자바 플랫폼을 모듈화하기 위해 도입되었다
	- JPMS를 통해 애플리케이션과 라이브러리를 모듈화할 수 있다
	- 모듈은 패키지의 모음이다
	- 모듈은 캡슐화를 제공한다. 모듈 외부에서 접근할 수 있는 패키지는 명시적으로 익스포트해야 한다

---
## 모듈 개념 잡기

OOP에서 기본 빌딩 블록은 클래스다. 클래스는 캡슐화를 제공한다. 비공개 기능은 명시적인 권한이 있는 코드(즉, 클래스의 메서드)로만 접근할 수 있다.

자바에서 패키지는 클래스보다 큰 구조화 수단이다. 패키지는 기본적으로 클래스의 모음이다. 패키지 또한 한 단계의 캡슐화를 제공한다. 접근 권한이 패키지(공개도 아니고 비공개도 아니다)로 설정된 기능은 같은 패키지에 속한 메서드에서만 접근할 수 있다.

하지만 대규모 시스템에서는 이런 접근 제어 수준으로는 충분하지 않다. 공개 기능(즉, 패키지 외부에서 접근할 수 있는 기능)은 어디에서나 접근할 수 있다. 거의 사용하지 않는 기능을 수정하거나 삭제하려 한다고 하자. 기능을 공개한 후에는 해당 변경이 주는 영향을 추론할 방법이 없다.

CMake에 익숙하다면 target_include_directory와 target_link_library를 떠올려보자.
- target_include_directory에 public으로 포함된 헤더만이 외부에서 접근 가능
- target_link_library에 public으로 연결된 경우에만 의존성이 전파됨

---
## 모듈식 "Hello, World!" 프로그램
이름 없는 패키지(unnamed package)는 모듈에 포함될 수 없다.

```java
package com.horstmann.hello;

public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("Hello, Modular World!");
	}
}
```

```bash
ch15.sec03/
└ module-info.java
  com/
  └ hosrtmann/
    └ hello - HelloWorld.java
```

모듈에는 선언(module declaration)이 필요하다:
```java
// module-info.java 파일에 다음 모듈 선언 추가:
module ch15.sec03 { }
```

모듈이 제공하는 것도, 제공받는 것도 없다는 의미이다.

---
## 모듈 요구
### 15.4 모듈 요구
```java
module ch15.sec04 {
	requires java.desktop;
}
```
![[core java 9 - modules.png|400]]
위와 같은 의존 관계가 형성된다.

---
## 패키지 익스포트
```java
// java.xml 모듈
module java.xml {
	exports javax.xml;
	exports java.xml.catalog;
	...
}
```

패키지를 익스포트하면 모듈의 public 및 protected 클래스와 인터페이스, public 및 protected 멤버를 해당 모듈 외부에서 접근할 수 있다.

익스포트 하지 않은 패키지는 모듈 외부에서 접근할 수 없다. 이는 모듈 시스템을 도입하기 전 자바와는 크게 다른 점이다. 자바 9 이전에는 공개 API의 일부가 아니더라도 모든 패키지의 공개 클래스를 사용할 수 있었다.

---

## 참고자료
- \[1\] 가장 빨리 만나는 코어 자바 9, 카이 호스트만, 2018